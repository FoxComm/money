package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"text/template"
)

const (
	note         = "// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT."
	jsonPath     = "./internal/currencies.json"
	currencyPath = "./currency/%s.go"
)

type Currency struct {
	Code      string `json:"iso_code"`
	Number    string `json:"iso_numeric"`
	Name      string `json:"name"`
	Symbol    string `json:"symbol"`
	Decimal   string `json:"decimal_mark"`
	Delimiter string `json:"thousands_separator"`
	Minor     int    `json:"subunit_to_unit"`
}

var funcMap = template.FuncMap{
	"ToUpper": strings.ToUpper,
}

var tmpl = template.Must(template.New("currency-file").Funcs(funcMap).Parse(`
package currency

// {{ .Code }} is the {{ .Name }} Currency
var {{ .Code }} = Currency{
	Code: "{{ .Code | ToUpper }}",
	Number: {{ .Number }},
	Symbol: '{{ .Symbol }}',
	Decimal: '{{ .Decimal }}',
	Delimiter: '{{ .Delimiter }}',
	Minor: {{ .Minor }},
}

`))

func main() {
	var generate bool

	flag.BoolVar(&generate, "generate", false, "generate currencies from ./internal/currencies.json")
	flag.Parse()

	file, err := os.Open("./internal/currencies.json")
	if err != nil {
		panic(err)
	}

	var currencies map[string]Currency
	if err = json.NewDecoder(file).Decode(&currencies); err != nil {
		panic(err)
	}

	for name, currency := range currencies {
		buf := new(bytes.Buffer)
		buf.WriteString(note)

		if err := tmpl.Execute(buf, currency); err != nil {
			fmt.Printf("Failed to compile template for %v\n", currency)
			panic(err)
		}

		if err = ioutil.WriteFile(fmt.Sprintf(currencyPath, name), buf.Bytes(), 0644); err != nil {
			panic(err)
		}
	}
}
